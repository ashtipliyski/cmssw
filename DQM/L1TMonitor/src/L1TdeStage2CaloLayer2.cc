#include "DQM/L1TMonitor/interface/L1TdeStage2CaloLayer2.h"

L1TdeStage2CaloLayer2::L1TdeStage2CaloLayer2 (const edm::ParameterSet& ps)
  : monitorDir(ps.getUntrackedParameter<std::string>("monitorDir", "")),
    calol2JetCollectionData(consumes<l1t::JetBxCollection>(ps.getParameter<edm::InputTag>("calol2JetCollectionData"))),
    calol2JetCollectionEmul(consumes<l1t::JetBxCollection>(ps.getParameter<edm::InputTag>("calol2JetCollectionEmul"))),
    calol2EGammaCollectionData(consumes<l1t::EGammaBxCollection>(ps.getParameter<edm::InputTag>("calol2EGammaCollectionData"))),
    calol2EGammaCollectionEmul(consumes<l1t::EGammaBxCollection>(ps.getParameter<edm::InputTag>("calol2EGammaCollectionEmul"))),
    calol2TauCollectionData(consumes<l1t::TauBxCollection>(ps.getParameter<edm::InputTag>("calol2TauCollectionData"))),
    calol2TauCollectionEmul(consumes<l1t::TauBxCollection>(ps.getParameter<edm::InputTag>("calol2TauCollectionEmul"))),
    calol2EtSumCollectionData(consumes<l1t::EtSumBxCollection>(ps.getParameter<edm::InputTag>("calol2EtSumCollectionData"))),
    calol2EtSumCollectionEmul(consumes<l1t::EtSumBxCollection>(ps.getParameter<edm::InputTag>("calol2EtSumCollectionEmul"))),
    verbose(ps.getUntrackedParameter<bool> ("verbose", false))
{}

L1TdeStage2CaloLayer2::~L1TdeStage2CaloLayer2() {  
  exit(1);
}

void L1TdeStage2CaloLayer2::dqmBeginRun (edm::Run const &, edm::EventSetup const & evSetup) {}

void L1TdeStage2CaloLayer2::beginLuminosityBlock (const edm::LuminosityBlock& iLumi, const edm::EventSetup & evSetup) {}

/**
   Method to declare or "book" all histograms that will be part of module

   Histograms that are to be visualised as part of the DQM module should be 
   registered with the IBooker object any additional configuration such as title
   or axis labels and ranges. A good rule of thumb for the amount of 
   configuration is that it should be possible to understnand the contents of
   the histogram using the configuration received from this method since the
   plots generated by this module would later be stored into ROOT files for 
   transfer to the DQM system and it should be possible to ...

   @param DQMStore::IBooker&      ibooker
   @param edm::Run const & 
   @param edm::EventSetup const &

   @return void
*/
void L1TdeStage2CaloLayer2::bookHistograms(DQMStore::IBooker &ibooker, edm::Run const &, edm::EventSetup const&) {
  
  // setup the directory where the histograms are to be visualised, value is set
  // in constructor and taken from python configuration file for module
  ibooker.setCurrentFolder(monitorDir);

  // define histogram to hold 2D correlation plot of individual jets found in
  // data and emulation
  jetPt2DCorrelation = ibooker.book2D("jetPtCorrelation", "Jet p_T data-emul correlation", 1400, 0, 1400, 1400, 0, 1400);

  // for reference on arguments of book2D, see
  // https://cmssdt.cern.ch/SDT/doxygen/CMSSW_8_0_24/doc/html/df/d26/DQMStore_8cc_source.html#l01070
}

void L1TdeStage2CaloLayer2::analyze (const edm::Event& e,  const edm::EventSetup & c) {
  
  if (verbose) edm::LogInfo("L1TdeStage2CaloLayer2") << "L1TdeStage2CaloLayer2: analyse " << std::endl;

  edm::Handle<l1t::JetBxCollection> jetsData;
  edm::Handle<l1t::JetBxCollection> jetsEmul;
  e.getByToken(calol2JetCollectionData, jetsData);
  e.getByToken(calol2JetCollectionEmul, jetsEmul);

  // check the bx ranges (if the number of BX stored in the data and emul collections is 
  // different, make a not of it)

  // loop over the different bx associated with the collections (choose one)

  // at each iteration:

  // skip BXs which do not exist in the "other" collection (the one not being 
  // looped over)

  // extract the data and emul jet collections for each BX
  // this loop can be used to populate all histograms associated with a given object,
  // i.e. pT, eta, phi, etc

  // while looping over the two collections one can assume that both collections have
  // the objects sorted in the same order which would only require to compare the
  // objects available at the current iteration.

  /**
     Questions:
     - what could make the data and emul bx ranges to be different?
     - how can I confirm that the emulator data is being filled?
  */

  int bxRangeEmul = jetsEmul->getLastBX() - jetsEmul->getFirstBX();
  int bxRangeData = jetsData->getLastBX() - jetsData->getFirstBX();
  
  std::cout << "Terminating output. " << jetsEmul->getFirstBX() << endl;

  if (bxRangeEmul == bxRangeData ) {

    std::cout << "emul first bx: " << jetsEmul->getFirstBX() << "; emul last bx: " 
	      << jetsEmul->getLastBX() << std::endl;
    std::cout << "data bx range: " << bxRangeData << std::endl;
    std::cout << "emul bx range: " << bxRangeEmul << std::endl;

  }
}

DEFINE_FWK_MODULE (L1TdeStage2CaloLayer2);
