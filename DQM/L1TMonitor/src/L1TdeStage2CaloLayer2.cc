#include "DQM/L1TMonitor/interface/L1TdeStage2CaloLayer2.h"

L1TdeStage2CaloLayer2::L1TdeStage2CaloLayer2 (const edm::ParameterSet& ps)
  : monitorDir(ps.getUntrackedParameter<std::string>("monitorDir", "")),
    calol2JetCollectionData(consumes<l1t::JetBxCollection>(ps.getParameter<edm::InputTag>("calol2JetCollectionData"))),
    calol2JetCollectionEmul(consumes<l1t::JetBxCollection>(ps.getParameter<edm::InputTag>("calol2JetCollectionEmul"))),
    calol2EGammaCollectionData(consumes<l1t::EGammaBxCollection>(ps.getParameter<edm::InputTag>("calol2EGammaCollectionData"))),
    calol2EGammaCollectionEmul(consumes<l1t::EGammaBxCollection>(ps.getParameter<edm::InputTag>("calol2EGammaCollectionEmul"))),
    calol2TauCollectionData(consumes<l1t::TauBxCollection>(ps.getParameter<edm::InputTag>("calol2TauCollectionData"))),
    calol2TauCollectionEmul(consumes<l1t::TauBxCollection>(ps.getParameter<edm::InputTag>("calol2TauCollectionEmul"))),
    calol2EtSumCollectionData(consumes<l1t::EtSumBxCollection>(ps.getParameter<edm::InputTag>("calol2EtSumCollectionData"))),
    calol2EtSumCollectionEmul(consumes<l1t::EtSumBxCollection>(ps.getParameter<edm::InputTag>("calol2EtSumCollectionEmul"))),
    verbose(ps.getUntrackedParameter<bool> ("verbose", false))
{}

L1TdeStage2CaloLayer2::~L1TdeStage2CaloLayer2() {}

void L1TdeStage2CaloLayer2::dqmBeginRun (
  edm::Run const &,
  edm::EventSetup const & evSetup) {}

void L1TdeStage2CaloLayer2::beginLuminosityBlock (
  const edm::LuminosityBlock& iLumi,
  const edm::EventSetup & evSetup) {}

/**
   Method to declare or "book" all histograms that will be part of module

   Histograms that are to be visualised as part of the DQM module should be
   registered with the IBooker object any additional configuration such as title
   or axis labels and ranges. A good rule of thumb for the amount of
   configuration is that it should be possible to understnand the contents of
   the histogram using the configuration received from this method since the
   plots generated by this module would later be stored into ROOT files for
   transfer to the DQM system and it should be possible to ...

   @param DQMStore::IBooker&      ibooker
   @param edm::Run const &
   @param edm::EventSetup const &

   @return void
*/
void L1TdeStage2CaloLayer2::bookHistograms(
  DQMStore::IBooker &ibooker,
  edm::Run const &,
  edm::EventSetup const&) {

  std::cout << "Booking histograms" << std::endl;

  // setup the directory where the histograms are to be visualised, value is set
  // in constructor and taken from python configuration file for module
  ibooker.setCurrentFolder(monitorDir);
  sampleHist = ibooker.book1D("sample", "hist", 1000, -0.5, 999.5);

  // define histogram to hold 2D correlation plot of individual jets found in
  // data and emulation

  // Jet energy in MP firmware is stored in 16 bits which sets the range of
  // jet energy to 2^16 * 0.5 GeV = 32768 GeV (65536 hardware units)
  jetPt2DCorr = ibooker.book2D(
    "jetPtCorrelation",
    "Jet p_T data-emul correlation; Data Jet p_{T}; Emul Jet p_{T}",
    32768, 0, 32768,
    32768, 0, 32768);

  return;

  // jetPt2DCorrelation->setAxisTitle("Data Jet p_T, GeV", 1); // x axis
  // jetPt2DCorrelation->setAxisTitle("Emul Jet p_T, GeV", 2); // y axis

  // for reference on arguments of book2D, see
  // https://cmssdt.cern.ch/SDT/doxygen/CMSSW_8_0_24/doc/html/df/d26/DQMStore_8cc_source.html#l01070
}

void L1TdeStage2CaloLayer2::analyze (
  const edm::Event& e,
  const edm::EventSetup & c) {

  std::cout << "analyse method" << std::endl;

  if (verbose)
    edm::LogInfo("L1TdeStage2CaloLayer2") << "L1TdeStage2CaloLayer2: analyse "
					  << std::endl;

  edm::Handle<l1t::JetBxCollection> jetData;
  edm::Handle<l1t::JetBxCollection> jetEmul;
  e.getByToken(calol2JetCollectionData, jetData);
  e.getByToken(calol2JetCollectionEmul, jetEmul);

  std::cout << "Jet event by event comparisons. " << std::endl;

  unsigned int currBx = 0;
  // we assume that the first and last bx of the emulator data is 0 since it is
  // very unlikely to have received RAW data from more than just the triggered
  // bx

  /**
     Notes:
     - The hardware can send up to 12 jets due to bandwidth limitation so it
       will sort the jets it has found in order of decreasing pT and will send
       only the top 12. The emulator does not have similar constraint but can be
       configured to truncate the list of jets it has found. In the case that a
       small number of jets is found (less than 12), the full list will be sent.
     - Currently, the edge case where the number of jets/objects in data and
       emulator are different is being skipped but would need to be addressed
       before the module can be declared complete. 

     Edge cases to consider:
     - there are more emulator jets than data jets
     - there are more data jets than emulator jets
     - missing jet is at beginning/end
     - missing jet is in the middle
  */

  std::cout << "set bx collection iterators" << std::endl;
  l1t::JetBxCollection::const_iterator dataJetIt = jetData->begin(currBx);
  l1t::JetBxCollection::const_iterator emulJetIt = jetEmul->begin(currBx);
  std::cout << jetData->size() << " jets found in event data" << std::endl;
  std::cout << jetEmul->size() << " jets found in event emulation" << std::endl;
  std::cout << "initiate jet loop" << std::endl;

  if (jetData->size() != jetEmul->size())
    return;

  if (dataJetIt != jetData->end(currBx) || emulJetIt != jetEmul->end(currBx)) {
    while(true) {

      std::cout << "data jet found: pT = " << dataJetIt->hwPt() << std::endl;
      std::cout << "emul jet found: pT = " << emulJetIt->hwPt() << std::endl;

      // jetPt2DCorrelation->Fill(dataJetIt->hwPt(), emulJetIt->hwPt());
      // jetPt2DCorrelation->Fill(2, 1);
      sampleHist->Fill(3.5);

      if (dataJetIt == jetData->end(currBx) || emulJetIt == jetEmul->end(currBx))
	break;

      ++dataJetIt;
      ++emulJetIt;

    }
  }

  // loop over the different bx associated with the collections (choose one)

  // at each iteration:

  // skip BXs which do not exist in the "other" collection (the one not being
  // looped over)

  // extract the data and emul jet collections for each BX
  // this loop can be used to populate all histograms associated with a given
  // object, i.e. pT, eta, phi, etc

  // while looping over the two collections one can assume that both collections
  // have the objects sorted in the same order which would only require to
  // compare the objects available at the current iteration.

  /**
     Questions:
     - what could make the data and emul bx ranges to be different?
     - how can I confirm that the emulator data is being filled?
  */

  /*

  edm::Handle<l1t::EGammaBxCollection> egammaData;
  edm::Handle<l1t::EGammaBxCollection> egammaEmul;
  e.getByToken(calol2EGammaCollectionData, egammaData);
  e.getByToken(calol2EGammaCollectionEmul, egammaEmul);

  std::cout << "egamma: " << egammaEmul->getFirstBX() << " "
  << egammaEmul->getLastBX() << std::endl;

  edm::Handle<l1t::TauBxCollection> tauData;
  edm::Handle<l1t::TauBxCollection> tauEmul;
  e.getByToken(calol2TauCollectionData, tauData);
  e.getByToken(calol2TauCollectionEmul, tauEmul);

  std::cout << "tau: " << tauEmul->getFirstBX() << " "
	    << tauEmul->getLastBX() << std::endl;

  edm::Handle<l1t::EtSumBxCollection> etsumData;
  edm::Handle<l1t::EtSumBxCollection> etsumEmul;
  e.getByToken(calol2EtSumCollectionData, etsumData);
  e.getByToken(calol2EtSumCollectionEmul, etsumEmul);

  std::cout << "etsum: " << etsumEmul->getFirstBX() << " "
	    << etsumEmul->getLastBX() << std::endl;
  */
}

DEFINE_FWK_MODULE (L1TdeStage2CaloLayer2);
